<!DOCTYPE HTML>
<html>

<head>
    <title>Pre-alpha</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="pragma" content="no-cache" />
    <meta http-equiv="no-cache" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv='expires' content='-1' />
    <style type="text/css">
        body {
            font-family: Garamond;
            font-size: 15px;
            font-weight: 300;
            margin: 30px;
            background: #C2CFFF;
        }

        .version {
            color: #BBC1E1;
            font-size: 11px;
            user-select: none;
        }

        :focus {
            outline: 0;
            outline-offset: 0;
        }

        .container {
            width: 670px;
            background: #fff;
            margin: 0 auto;
            overflow: hidden;
            box-shadow: 5px 5px 30px #aaa;
            border-radius: 5px;
            padding: 20px;
        }

        .startbar {
            width: 300px;
            display: flex;
            margin: 10px 0 0 0;
            justify-content: space-around;
            background: #FFFFFF;
            border: 1px solid #ddd;
            border-radius: 1px;
            padding: 10px;
        }

        .inputTime {
            color: #BBC1E1;
            border: none;
            border-bottom: 1px solid #BBC1E1;
        }

        .inputTime:focus {
            color: #28305C;
        }

        .timebar {
            width: 300px;
            display: flex;
            margin: 10px 0 0 0;
            justify-content: space-around;
            background: #FFFFFF;
            border: 1px solid #ddd;
            border-radius: 1px;
            padding: 10px;
            user-select: none;
        }

        .adminbar {
            width: 300px;
            display: flex;
            margin: 10px 0 0 0;
            justify-content: space-around;
            background: #FFFFFF;
            border: 1px solid #ddd;
            border-radius: 1px;
            padding: 10px;
        }

        .switchbar {
            width: 300px;
            display: flex;
            margin: 10px 0 0 0;
            justify-content: space-around;
            background: #FFFFFF;
            border: 1px solid #ddd;
            border-radius: 1px;
            padding: 10px;
        }

        .checkbox_div {
            padding: 0 6px 0 0;
            /*  vnutrinie otstup */
            /*  sverhu 0    */
            /*  sprava 6px  */
            /*  snizu 0     */
            /*  sleva  0    */
            user-select: none;
        }

        label.switch {
            display: inline-block;
            width: 25px;
            height: 15px;
            background-color: white;
            border: 1px solid #BBC1E1;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease-out;
            user-select: none;
        }

        input[type="checkbox"] {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background-color: #BBC1E1;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease-out;
        }

        input[type="checkbox"]:checked {
            -webkit-transform: translateX(7px);
            background-color: #28305C;
        }

        input[type="checkbox"]:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .logbar {
            font-size: 10px;
            width: 300px;
            display: flex;
            margin: 10px 0 0 0;
            background: #FFFFFF;
            border: 1px solid #ddd;
            border-radius: 1px;
            padding: 10px;
            user-select: none;
        }

        .tablica {
            font-family: Garamond;
            height: 260px;
            max-width: 700px;
            overflow-x: auto;
            margin-top: 10px;
            margin-bottom: 20px;
            background: #FFFFFF;
            border: 1px solid #ddd;
            border-radius: 1px;
        }

        table {
            width: 100%;
            background: #FFFFFF;
            border: 1px solid #ddd;
            table-layout: auto;
            border-collapse: collapse;
        }

        th {
            background: #28305C;
            text-align: left;
            color: #fff;
            padding: 12px;
            font-size: 15px;
            font-weight: 100;
        }

        tr {
            font-size: 12px;
            border: 1px solid #ddd;
            height: 20px;
            text-align: left;
        }

        tr:hover {
            background-color: #28305C;
            color: #FFFFFF;
        }

        td {
            padding: 0 25px;
            vertical-align: middle;
        }


        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            box-shadow: inset 0 0 6px #BBC1E1;
        }

        ::-webkit-scrollbar-thumb {
            box-shadow: inset 0 0 6px #28305C;
        }

        .textcols {
            column-width: 48%;
            column-count: 3;
            font-size: 10px;
            background: #FFFFFF;
            border: 1px solid #ddd;
            border-radius: 1px;
            overflow: hidden;
            padding: 12px;
            width: 700px;
            height: 200px;
        }

        button {
            border: none;
            border-radius: 2px;
            padding: 10px 15px;
            margin: 2px;
            font-size: 15px;
            cursor: pointer;
            color: #BBC1E1;
            background-color: #28305C;
            background-position: center;
            transition: background 0.8s;
            touch-action: none;
            -webkit-touch-callout: none;
            user-drag: none;
            user-select: none;
        }

        button:hover {
            background: #22294E radial-gradient(circle, transparent 1%, #22294E 1%) center/15000%;
            box-shadow: 0 0 7px #999;
            color: white;
        }

        button:active {
            background-color: #171C35;
            background-size: 100%;
            transition: background 0s;
            box-shadow: 0 0 2px #999;
        }
    </style>
</head>

<body>
    <div class="version"></div>

    <div class="container">
        <a href="test/coin.html">coin</a>
        <a href="test.html">test</a>

        <div class="startbar">
            <input type="text" class="inputTime" value="">
            <button onclick="button1();">Go</button>
        </div>

        <div class="timebar">
            <div class="clock" id="id">00:00:00</div>
            <div class="timer" id="id">Time: <span class="min">0:00</span><br></div>
        </div>

        <div class="adminbar">
            <button onclick="buttonClearStorage()">Clear</button>
            <button class="btn-binance" onclick=buttonOpenLink("https://www.binance.com/ru/trade/BTC_USDT?layout=basic")> BTC</button>
            <button class="btn-binance" onclick=buttonOpenLink("https://www.binance.com/ru/trade/SOL_USDT?layout=basic")> SOL</button>
            <div class="soundNotification">
                <audio id="audio">
                    <source src="alarm.mp3" type="audio/mpeg">
                </audio>
                <button onclick="audio.pause()">Stop</button>
            </div>
        </div>

        <div class="switchbar">
            <label class="switch"><input type="checkbox" class="debug"></label>
            <div class="checkbox_div">debug</div>
            <label class="switch"><input type="checkbox" class="checkbox"></label>
            <div class="checkbox_div">checkbox</div>
            <label class="switch"><input type="checkbox" class="checkbox"></label>
            <div class="checkbox_div">checkbox 2 </div>
        </div>

        <div class="logbar">
            <output class="logError">Log: </output>
        </div>

        <div class="tablica">
            <table>
                <thead>
                    <tr>
                        <th>Coin</th>
                        <th>%</th>
                        <th>Price</th>
                        <th>Strategy</th>
                        <th>Signal</th>
                        <th>Time</th>
                    </tr>
                </thead>
            </table>
            <div class="scroll_table">
                <table>
                    <tbody class="new_table">
                    </tbody>
                </table>
            </div>
        </div>

        <div class="textcols">
            <p>BTC: [$100] 0.85% (15m)</p>
            <p>BTC: [$50] 0.34% (5m) </p>
            <p>BTC: [$10] 0.25% (1m) test*</p>
            <p>BTC: [$10] 0.30% (1m) NEW*</p>
            <p>ETH: [$5] 0.55% (5m)</p>
            <p>ETH: [$3] 0.40% (1m) pririotet*</p>
            <p>ETH: [$3] 0.30% (1m) NEW*</p>
            <p>SOL: [$0.50] 1.60% (15m) risk*</p>
            <p>SOL: [$0.30] 0.74% - 0.90% (5m) </p>
            <p>SOL: [$0.30] 1.40% - 1.50% (5m) NEW*</p>
            <p>SOL: [$0.15] 0.60% (1m) pririotet*</p>
            <p>SOL: [$0.30] 1.60% (1m) NEW*</p>
            <p>SOL: [$0.30] 0.80% (1m) NEW*</p>
            <p>BNB: [$1] 1.20% (15m) </p>
            <p>BNB: [$0.5] 0.70% (5m)</p>
            <p>XRP: [$0.0010] 0.85% (5m)</p>
            <p>XRP: [$0.0005] 0.60% (1m)</p>
            <p>DOT: [$0.05] 0.70%-0.80% (1m)</p>
            <p>DOT: [$0.05] 0.81% (5m)</p>
            <p>LINK: [$0.10] 0.55% (5m)</p>
            <p>LINK: [$0.05] 0.38% (1m)</p>
            <p>LINK: [$0.01] 0.90% (5m)</p>
        </div>

    </div>
    <script>
        const version = async (data) => {
            document.querySelector(".version").textContent = data;
        };
        /*
         *
         * Release:  v.0.9 (13.09.2021)
         * + подготовка к большим изменений в версии 1.0
         * + правки кода
         * + исправлено мелких ошибок
         *
         */
        version("Pre-release: v.1.0.2");
        /*
         * Pre-release: v.1.0.2
         * + новый дизайн
         * + база данных (localStorage)
         * + переписан код (es6)
         * + добавлено теги "no-cache"
         * + многопоточность (более 1 стратегий)
         * - единственная  функция по обработке ошибок try catch
         * - автоисправление сетевых ошибок
         * - панель анализа данных
         * - функция психологической поддержки
         * - серверная часть
         * - уведомления на телеграм
         * - стратегии на другие криптовалюты
         * - улучшение дизайна
         * - график (и скриншоты) свеч для сравнения и анализа
         * - улучшить debug()
         */

        /* https://vc.ru/finance/207749-kak-ya-torgovyh-robotov-razrabatyval
         *  - статегия BTC/USDT -- ETH/USDT 5m
         *  1. если предедужчая свеча больше 0.50%, не покупать.(нужна база даных)
         *  2. если 1m стратегия не сработала, не покупать.
         *
         *  - статегия SOL/USDT 1m-5m
         *  3. если за последние 1 часа был сигнал и сработала покупка (в пределах 1 ч),
         *     следующий сигнал  в премижутку 1 часа, не покупать.
         *  4. если сиглал свеча више 1.80%(5м), 1.50%(1м), не покупать.
         *  5. если цена близко до круглих значений 115, 120, 125, не покупать.
         *  6. если тренд низходящий, не покупать.
         *  6.1. если последные 15 мин есть свечи (2шт.) с болышими минусами (-0.70%), не покупать.
         *  7. если предудущая свеча с большим минусом (-0.40%)(1m), покупать, но  п.6 и 6.1.
         *  8. если торги идут с 9:00 по 21:00
         *  9. если цена  приблизилась до пиковой дневной(24ч) цены, не покупать.
         *  10. если предедужчые 2 свечы больше(1m) или 3 свечы(15m), не покупать
         *  11. если BTC растет, SOL  не покупать.
         *  12. если обем торгов по SELLкраснай больше 30к(SOL) будет падать, не покупать.
         *
         *
         *
         *  - стратегия по убиткам:
         *   1. если после сигнала, следуючие 2 свечи -0.30% -- сигнал на убыток = продавать
         */


        let debug = async (result) => {
            if (document.querySelector(".debug").checked) {
                console.log(debug.name + ": " + result);
            }
        };
        /*
        console.count("debug");
        console.trace();
        console.log(debug.name);
        var time = performance.now();

        time = performance.now() - time;
        console.log('js work = ', time);

            const getURLParameters = url =>
                (url.match(/([^?=&]+)(=([^&]*))/g) || []).reduce(
                    (a, v) => (
                        (a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1)), a
                    ), {}
                );
            getURLParameters('google.com'); // {}
            getURLParameters('http://url.com/page?name=Adam&surname=Smith');
        };          */


        const clock = async () => {
            const time = new Date().toLocaleTimeString();
            document.querySelector(".clock").textContent = time;
        };
        setInterval(() => clock(), 1000);



        const myDB = () => {
            const db = {
                BTC: "BTCUSDT",
                ETH: "ETHUSDT",
                SOL: "SOLUSDT",
                interval: {
                    s1: 1,
                    s5: 5,
                    s15: 15
                },
                strategy: {
                    BTC_s1: {
                        min: 0.30,
                        max: 2
                    },
                    ETH_s1: {
                        min: 0.45,
                        max: 2
                    },
                    SOL_s1: {
                        min: 0.80,
                        max: 2
                    }
                },

            };
            localStorage.setItem("setting", JSON.stringify(db));
            //debug("myDB - "+JSON.stringify(db));
            return JSON.parse(localStorage.getItem("setting"));
        };


        //console.log(myDB().symbol.ETH);
        //console.log(myDB().interval.s1);
        //console.log(myDB().strategy.BTC_s1);

        let setTimeDB = (s1, s5, s15) => {
            let time = {
                interval1: [],
                interval2: [],
                interval3: []
            };
            if (s1) {
                time.interval1.push(s1);
            }
            if (s5) {
                time.interval2.push(s5);
            }
            if (s15) {
                time.interval3.push(s15);
            }
            localStorage.setItem("settingTime", JSON.stringify(time));
        };
        //setTimeDB(1631196840000, null, null);

        let getTimeDB = () => {
            const p = JSON.parse(localStorage.getItem("settingTime"));
            //console.log(p.timeBTC[0]);
            return {
                s1: p.interval1[0],
                s5: p.interval2[0],
                s15: p.interval3[0]
            };
        }
        //console.log(getTimeDB().s1);
        // console.log(getTimeDB().s5);

        const timeUnix = () => { // 10:00:00 2021-08-16 --> 1629108000000
            const input = document.querySelector(".inputTime").value;
            debug(input);
            const unix = Date.parse(input);
            debug(unix);
            return unix;
        };
        const timeDate = () => {
            const time = new Date().toLocaleTimeString();
            const date = new Date().toISOString().slice(0, 10);
            document.querySelector(".inputTime").value = time.slice(0, 5) + " " + date; // ��������� � ���� ��������� ����� hh/mm
            return time + " " + date;
        };
        const timer = async (time) => {
            let t = time,
                min, sec;
            let timerId = setInterval(function() {
                min = parseInt(t / 60, 10);
                sec = parseInt(t % 60, 10);
                min = min < 10 ? "0" + min : min;
                sec = sec < 10 ? "0" + sec : sec;
                debug(min + ":" + sec);
                document.querySelector(".min").textContent = min + ":" + sec;
                if (--t < 0) {
                    clearTimeout(timerId);
                    document.querySelector(".min").textContent = "";
                }
            }, 1000);
        };


        const getUrl = (symbol, interval, startTime) => {
            let url = new URL("https://api.binance.com/api/v1/klines"); // https://api.binance.com/api/v3/time
            url.searchParams.set("symbol", symbol); // + "USDT"
            url.searchParams.set("interval", interval + "m"); // parseInt('100m')
            url.searchParams.set("startTime", startTime);
            debug(url);
            return url;
        };

        const getProcent = (v1, v2) => {
            return (((v2 - v1) / Math.abs(v1)) * 100).toFixed(2);
        };

        const getError = (x) => {
            const audio = new Audio();
            audio.src = "error.mp3";
            audio.autoplay = true;
            const elem = document.querySelector(".logError");
            const data = document.createTextNode(" [" +x+ "] ");
            elem.appendChild(data);
        };

        const getRequest = async (symbol, url) => {
            try {
                let xhr = await fetch(url);
                let xhrJson = await xhr.json();
                //debug(xhrJson);
                //console.log("fetch " + xhrJson[1][0]);
                await check(symbol, xhrJson);
                if (xhrJson.length > 2 || !xhrJson.length) {
                    getError("not correct url");
                    throw new Error("not correct url: " + xhrJson.length, xhr.status);
                }
                //await check(symbol, xhrJson);
            } catch (err) {
                console.log(err, err.message);
                getError("error internet");
            }

        };

        const check = (symbol, xhrJson) => {
            let firstPrice = xhrJson[0][1];
            let lastPrice = xhrJson[0][4];
            let procent = getProcent(firstPrice, lastPrice);
            setTimeDB(xhrJson[1][0], null, null);
            //addTable([setting("symbol"), procent(price[0][1], price[0][4]) + "%", "$" + price[0][1], setting("procent"), signal(procent(price[0][1], price[0][4])), timeDate()]);
            addTable([symbol, procent + "%", "$" + lastPrice, "procent", signal(symbol, procent), timeDate()]);
            timer(60 * myDB().interval.s1);
            console.log(xhrJson);
        };

        const signal = (symbol, data) => {
            const s = symbol;
            const BUY = localStorage.getItem(s);
            localStorage.getItem(s);
            debug(BUY);
            const lastBUY = (start, end) => {
                const currDate = new Date(start);
                const oldDate = new Date(end);
                const result = (oldDate - currDate) / 60000;
                return result.toFixed(0)
            };
            const strategyBUY = () => {
                if (s === myDB().BTC) {
                    return myDB().strategy.BTC_s1;
                }
                if (s === myDB().ETH) {
                    return myDB().strategy.ETH_s1;
                }
                if (s === myDB().SOL) {
                    return myDB().strategy.SOL_s1;
                }
            };
            if (data >= strategyBUY().min) {
                console.log("PRICE GOOD % " + s);
                if (data < strategyBUY().max) {
                    console.log(s + " PRICE < " + strategyBUY().max);
                    if (lastBUY(BUY, timeDate()) >= 60) {
                        console.log(lastBUY(BUY, timeDate()) + " min " + s);
                        localStorage.setItem(s, timeDate());
                        //pushNotifications("Go", "BUY bitcoin");
                        soundNotification();
                        return "BUY";
                    }
                    console.log("60 min > NO BUY" + s);
                    soundNotification();
                }
                return "no recommend";
            }
            if (data < -0.30) {
                return "warning";

            } else {
                return "---";
            }
        };

        const addTable = async (data) => {
            const tbody = document.querySelector(".new_table");
            const tr = document.createElement("tr");
            tr.setAttribute("class", "new_tr");
            for (let i = 0; i < data.length; i++) {
                tr.appendChild(document.createElement("td")).appendChild(document.createTextNode(data[i]));
            }
            tbody.prepend(tr);
        };

        const soundNotification = () => {
            //const audio = document.querySelector(".audio");
            audio.play(); //    «audio» по id селектера
            document.onkeydown = function(event) {
                if (event.keyCode === 32) {
                    event.preventDefault();
                    event.stopImmediatePropagation();
                    audio.pause();
                }
            };
            //const audio = new Audio();
            // audio.src = "alarm.mp3";
            //audio.autoplay = true; // Автоматически запускаем
        };
        const buttonClearStorage = () => {
            localStorage.clear();
            console.clear();
            //localStorage.removeItem("startTime");
            //localStorage.removeItem("endTime");
        };
        const buttonOpenLink = (url) => {
            window.open(url, "_blank");
            //console.log(open);
        };
        const button1 = () => {
            //let db = myDB();
            setTimeDB(timeUnix(), null, null);
            getRequest(myDB().BTC, getUrl(myDB().BTC, myDB().interval.s1, getTimeDB().s1));
            getRequest(myDB().ETH, getUrl(myDB().ETH, myDB().interval.s1, getTimeDB().s1));
            getRequest(myDB().SOL, getUrl(myDB().SOL, myDB().interval.s1, getTimeDB().s1));
            setInterval(function() {
                getRequest(myDB().BTC, getUrl(myDB().BTC, myDB().interval.s1, getTimeDB().s1));
                getRequest(myDB().ETH, getUrl(myDB().ETH, myDB().interval.s1, getTimeDB().s1));
                getRequest(myDB().SOL, getUrl(myDB().SOL, myDB().interval.s1, getTimeDB().s1));
            }, 60000 * myDB().interval.s1)
        };
        /*
        function goBTC() {

            getRequest(getUrl(myDB().symbol.BTC, myDB().interval.s1, getTimeDB().BTC));
            setInterval(function() {
            getRequest(getUrl(myDB().symbol.BTC, myDB().interval.s1, getTimeDB().BTC));
            }, 60000 * myDB().interval.s1)

        };
         function goSOL() {
            setTimeDB(null, null, timeUnix());
            getRequest(getUrl(myDB().symbol.SOL, myDB().interval.s1, getTimeDB().SOL));
            setInterval(function() {
            getRequest(getUrl(myDB().symbol.SOL, myDB().interval.s1, getTimeDB().SOL));
            }, 60000 * myDB().interval.s1)

        };
            */
        timeDate();



        /*
        var localstorage = {
            set: function(key, value) {
                window.localStorage.setItem(key, JSON.stringify(value));
            },
            get: function(key) {
                try {
                    return JSON.parse(window.localStorage.getItem(key));
                } catch (e) {
                    return null;
                }
            }
        };
        //console.log(localstorage.get(["myKey.interval"]) );


                function localStorageTime() {
                    if (localStorage.getItem("startTime")) { // ���� ���� ��������� �����
                        return localStorage.getItem("endTime"); // ��������� ��������� ����� � �������
                    } else { // ���� ���������(���������) ������� ���
                        localStorage.setItem("startTime", timeUnix()); // ����������� ��������� �����
                        return localStorage.getItem("startTime"); // ��������� ��������� ����� � �������
                    }
                    debug("�������� � ��������� ...");
                };

                        localStorage.setItem("endTime", price[1][0]); // ����������� ���������(���������) �����


                                    */
    </script>
</body>

</html>